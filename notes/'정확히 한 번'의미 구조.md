---
title: '''정확히 한 번''의미 구조'
created: '2025-01-11T12:35:15.599Z'
modified: '2025-01-12T07:27:46.145Z'
---

# 08. '정확히 한 번'의미 구조
## 멱등성 프로듀서
동일한 작업을 여러 번 실행해도 한 번 실행한 것과 결과가 같은 서비스를 멱등적이라고 한다.
프로듀서 설정
```
enable.idempotence=true
```
### 작동 원리
멱등성 프로듀서 기능을 켜면 모든 메시지는 고유한 **프로듀서 ID(PID)와 시퀀스 넘버(sequence ID)**를 갖게됨
- PID와 sequenceID로 중복인지 아닌지 판단
### 사용 사례
1. 프로듀서 재시작
```
1. 프로듀서 장애 발생
2. 개발자가 장비 재시작 또는 쿠버네티스와 같이 자동 장애 복구 기능을 제공하는 프레임워크를 사용해서 프로듀서 재시작
3. 멱등성 프로듀서 기능이 켜져 있을 경우, 프로듀서는 초기화 과정에서 카프카 브로커로부터 프로듀서 ID를 생성 받음
4. 만약 트랜잭션 기능을 켜지 않았을 경우 새로운 PID 생성
5. 새로운 PID이므로 새 PID를 받은 새 프로듀서가 기존 프로듀서가 이미 전송한 메시지를 다시 전송할 경우, 브로커는 메시지에 중복이 발생한걸 알아차리지 못함(기존 프로듀서가 다시 작동을 재개해도 마찬가지)
```
2. 브로커 장애

브로커 장애로 컨트롤러에서 새 리더를 선출한 경우
리더 레플리카 -> 브로커 5
팔로워 레플리카 -> 브로커 3

~~리더 레플리카 -> 브로커 5~~
리더 레플리카 -> 브로커 3

브로커 3 입장에서 어느 시퀀스 넘버까지 쓰여졌는지 어떻게 알지?
- 리더는 새 메시지가 쓰여질 때마다 인-메모리 프로듀서 상태에 저장된 최근 5개의 시퀀스 넘버 업데이트
- 팔로워는 리더로부터 새로운 메시지를 복제할 때마다 자체적이 인-메모리 버퍼를 업데이트
그래서 팔로워가 리더가 된 시점에는 이미 시퀀스 넘버를 알고 있음

만약 종료되었던 리더 레플리카가 다시 돌아온다면?
브로커가 종료될 때 프로듀서 상태에 대한 스냅샷(파일 형태) + 현재 리더 레플리카로부터 복제한 레코드를 사용해서 최신 상태 복구
### 한계
- 프로듀서가 `producer.send()`를 두 번 호출한 경우까지는 멱등성 프로듀서가 동일한 레코드인지 확인할 방법 없음
- 애플리케이션 레벨에서 재시도 하는것보단, 프로듀서에 탑재된 재시도 메커니즘을 사용하는 것이 좋음

| 프로듀서 자체의 재시도 메커니즘(프로듀너, 네트워크, 브로커 에러로 인해 발생하는)에 의한 중복만을 방지할 뿐, 그 이상은 하지 않음

### 사용법
- 프로듀서 ID를 받아오기 위해 프로듀서 시동 과정에서 API를 하나 더 호출
- 전송되는 각각의 레코드 배치에는 프로듀서 ID와 배치 내 첫 메시지의 시퀀스 넘버 포함(각 메시지의 시퀀스 넘버는 offset 방식으로 계산?)
- 브로커들은 모든 프로듀서 인스턴스에서 들어온 레코드 배치의 시퀀스 넘버를 검증
- 장애가 발생하더라도 파티션에 쓰여지는 메시지들의 순서는 보장

## 트랜잭션
카프카 스트림즈를 사용해서 개발된 애플리케이션에서 정확성을 보장하기 위해 도입
- 카프카 스트림즈
  - 예시) 이커머스에서 집계 데이터가 필요할때 order-completed 토픽을 구독하고, 결과를 집계하여 category-sales, total-sales같은 토픽에 다시 저장
입력 레코드는 정확히 한 번만 처리되어야 하고 처리 결과도 한 번만 반영 필요 -> 집계 데이터가 정확해야함
### 트랜잭션으로 해결할 수 있는 문제
#### 사례
1. 애플리케이션 크래시
원본 클러스터로부터 메시지를 읽어서 처리한 뒤, 애플리케이션은 결과를 1. 출력 토픽에 쓰고 2. 메시지의 오프셋을 _consumer_offests 토픽에 커밋해야 함
만약 출력 토픽에는 썼는데, 입력 오프셋을 커밋하기 전에 크래시가 난다면?
-> 몇 초가 지나면 리밸런스가 발생하여, 다른 컨슈머가 다시 출력 토픽에 씀 -> 중복 발생
2. 좀비 애플리케이션
만약 애플리케이션이 레코드 배치를 읽어온 직후, 문제가 발생한다면?
-> 몇 초가 지나면 리밸런스가 발생 -> 다른 컨슈머가 수행 -> 멈췄던 애플리케이션 재동작 -> 중복 메시지를 쓰게됨
이처럼 스스로가 죽은 상태인지 모르는 컨슈머를 좀비라고 부름
### 동작
**원자적 다수 파티션 쓰기** 도입
- 오프셋 커밋, 결과를 쓰는 건 모두 파티션에 메시지를 쓰는 작업
- 둘다 성공하거나, 둘다 안되거나를 보장
- `transactional.id` 가 설정되고, `initTransactions()`를 호출해서 초기화해주면 됨
  - `transactional.id`는 재시작 후에도 동일한 값 유지
- 좀비 펜싱
  - 에포크: initTransaction()을 호추하면 transactional.id에 해당하는 에포크 값을 증가시킨 후, 같은 transactional.id를 가지고 있지만 에포크 값은 낮은 프로듀서가 메시지 전송, 트랜잭션 커밋, 트랜잭션 중단 요청을 보낼 경우 오래된 프로듀서로 간주하여 에러 발생하면서 거부함
  > 펜싱: 분산 시스템에서 잘못된 리더나 노드의 잘못된 동작을 방지하기 위한 메커니즘
#### 트랜잭션으로 해결할 수 없는 문제들
1. 스트림 처리에 있어서의 부수 효과
2. 카프카 토픽에서 읽어서 데이터베이스에 쓴느 경우
3. 데이터베이스에서 읽어서, 카프카에 쓰고, 여기서 다시 다른 데이터베이스에 쓰는 경우
4. 한 클러스터에서 다른 클러스터로 데이터 복제
5. 발행/구독 패턴

 




